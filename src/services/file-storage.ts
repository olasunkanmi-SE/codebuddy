// Create a new file: src/storage/database.ts

import * as path from "path";
import { Logger, LogLevel } from "../infrastructure/logger/logger";
import { EditorHostService } from "./editor-host.service";

export interface IStorage {
  get<T>(key: string): Promise<T | undefined>;
  set<T>(key: string, value: T): Promise<void>;
  delete(key: string): Promise<void>;
  has(key: string): Promise<boolean>;
}

export class FileStorage implements IStorage {
  private storagePath = "";
  private readonly logger: Logger;
  private initPromise: Promise<void>;

  constructor() {
    this.logger = Logger.initialize(FileStorage.name, {
      minLevel: LogLevel.DEBUG,
      enableConsole: true,
      enableFile: true,
      enableTelemetry: true,
    });
    this.initPromise = this.createCodeBuddyFolder();
  }

  async createCodeBuddyFolder() {
    const host = EditorHostService.getInstance().getHost();
    const workSpaceRoot =
      host.workspace.workspaceFolders?.[0]?.uri.fsPath ?? "";
    this.storagePath = path.join(workSpaceRoot, ".codebuddy");

    try {
      await host.workspace.fs.stat(this.storagePath);
    } catch {
      await host.workspace.fs.createDirectory(this.storagePath);
    }
    await this.updateGitIgnore(workSpaceRoot, ".codebuddy");
  }

  /**
   * Updates or creates a .gitignore file with the specified pattern
   * @param workspaceRoot The root folder of the current workspace
   * @param pattern The pattern to add to .gitignore (e.g., '.codebuddy')
   */
  async updateGitIgnore(workspaceRoot: string, pattern: string): Promise<void> {
    const host = EditorHostService.getInstance().getHost();
    const gitIgnorePath = path.join(workspaceRoot, ".gitignore");

    let gitIgnoreContent = "";
    let fileExists = false;

    try {
      const contentBytes = await host.workspace.fs.readFile(gitIgnorePath);
      gitIgnoreContent = new TextDecoder().decode(contentBytes);
      fileExists = true;
    } catch {
      fileExists = false;
    }

    if (fileExists) {
      const lines = gitIgnoreContent.split(/\r?\n/);

      const patternExists = lines.some(
        (line) =>
          line.trim() === pattern ||
          line.trim() === `/${pattern}` ||
          line.trim() === `${pattern}/`,
      );

      if (!patternExists) {
        const newContent = gitIgnoreContent.endsWith("\n")
          ? `${gitIgnoreContent}${pattern}\n`
          : `${gitIgnoreContent}\n${pattern}\n`;

        await host.workspace.fs.writeFile(
          gitIgnorePath,
          new TextEncoder().encode(newContent),
        );
        this.logger.info(`Added ${pattern} to .gitignore`);
      }
    } else {
      await host.workspace.fs.writeFile(
        gitIgnorePath,
        new TextEncoder().encode(
          `# Generated by CodeBuddy Extension\n${pattern}\n`,
        ),
      );
      this.logger.info(`Created new .gitignore with ${pattern}`);
    }
  }

  private getFilePath(key: string): string {
    return path.join(this.storagePath, `${key}.json`);
  }

  async get<T>(key: string): Promise<T | undefined> {
    await this.initPromise;
    try {
      const host = EditorHostService.getInstance().getHost();
      const filePath = this.getFilePath(key);
      try {
        await host.workspace.fs.stat(filePath);
      } catch {
        return undefined;
      }
      const data = await host.workspace.fs.readFile(filePath);
      const content = new TextDecoder().decode(data);
      return JSON.parse(content) as T;
    } catch (error: any) {
      this.logger.error(`Error reading data for key ${key}:`, error);
      return undefined;
    }
  }

  async set<T>(key: string, value: T): Promise<void> {
    await this.initPromise;
    try {
      const host = EditorHostService.getInstance().getHost();
      const filePath = this.getFilePath(key);
      const content = JSON.stringify(value, null, 2);
      await host.workspace.fs.writeFile(
        filePath,
        new TextEncoder().encode(content),
      );
    } catch (error: any) {
      this.logger.error(`Error storing data for key ${key}:`, error);
      throw new Error(`Failed to store data: ${error}`);
    }
  }

  async delete(key: string): Promise<void> {
    await this.initPromise;
    try {
      const host = EditorHostService.getInstance().getHost();
      const filePath = this.getFilePath(key);
      try {
        await host.workspace.fs.stat(filePath);
        await host.workspace.fs.delete(filePath);
      } catch {
        // File doesn't exist, ignore
      }
    } catch (error: any) {
      this.logger.error(`Error deleting data for key ${key}:`, error);
    }
  }

  async has(key: string): Promise<boolean> {
    await this.initPromise;
    const host = EditorHostService.getInstance().getHost();
    const filePath = this.getFilePath(key);
    try {
      await host.workspace.fs.stat(filePath);
      return true;
    } catch {
      return false;
    }
  }
}
