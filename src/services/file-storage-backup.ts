// Create a new file: src/storage/database.ts

import * as fs from "fs";
import * as path from "path";
import * as vscode from "vscode";

export interface IStorage {
  get<T>(key: string): Promise<T | undefined>;
  set<T>(key: string, value: T): Promise<void>;
  delete(key: string): Promise<void>;
  has(key: string): Promise<boolean>;
}

export class FileStorage implements IStorage {
  private storagePath = "";
  private initialized = false;

  constructor() {
    // No async operations in constructor
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.createCodeBuddyFolder();
      this.initialized = true;
    }
  }

  async createCodeBuddyFolder() {
    const workSpaceRoot =
      vscode.workspace.workspaceFolders?.[0]?.uri.fsPath ?? "";
    this.storagePath = path.join(workSpaceRoot, ".codebuddy");
    if (!fs.existsSync(this.storagePath)) {
      fs.mkdirSync(this.storagePath, { recursive: true });
    }
    await this.updateGitIgnore(workSpaceRoot, ".codebuddy");
  }

  /**
   * Updates or creates a .gitignore file with the specified pattern
   * @param workspaceRoot The root folder of the current workspace
   * @param pattern The pattern to add to .gitignore (e.g., '.codebuddy')
   */
  async updateGitIgnore(workspaceRoot: string, pattern: string): Promise<void> {
    const gitIgnorePath = path.join(workspaceRoot, ".gitignore");

    if (fs.existsSync(gitIgnorePath)) {
      const gitIgnoreContent = fs.readFileSync(gitIgnorePath, "utf8");
      const lines = gitIgnoreContent.split(/\r?\n/);

      const patternExists = lines.some(
        (line) =>
          line.trim() === pattern ||
          line.trim() === `/${pattern}` ||
          line.trim() === `${pattern}/`,
      );

      if (!patternExists) {
        const newContent = gitIgnoreContent.endsWith("\n")
          ? `${gitIgnoreContent}${pattern}\n`
          : `${gitIgnoreContent}\n${pattern}\n`;

        fs.writeFileSync(gitIgnorePath, newContent, "utf8");
        console.log(`Added ${pattern} to .gitignore`);
      }
    } else {
      fs.writeFileSync(
        gitIgnorePath,
        `# Generated by CodeBuddy Extension\n${pattern}\n`,
        "utf8",
      );
      console.log(`Created new .gitignore with ${pattern}`);
    }
  }
  private getFilePath(key: string): string {
    return path.join(this.storagePath, `${key}.json`);
  }

  async get<T>(key: string): Promise<T | undefined> {
    await this.ensureInitialized();

    try {
      const filePath = this.getFilePath(key);
      if (!fs.existsSync(filePath)) {
        return undefined;
      }
      const data = await fs.promises.readFile(filePath, "utf-8");
      return JSON.parse(data) as T;
    } catch (error) {
      console.error(`Error reading data for key ${key}:`, error);
      return undefined;
    }
  }

  async set<T>(key: string, value: T): Promise<void> {
    await this.ensureInitialized();

    try {
      const filePath = this.getFilePath(key);
      await fs.promises.writeFile(
        filePath,
        JSON.stringify(value, null, 2),
        "utf-8",
      );
    } catch (error) {
      console.error(`Error storing data for key ${key}:`, error);
      throw new Error(`Failed to store data: ${error}`);
    }
  }

  async delete(key: string): Promise<void> {
    await this.ensureInitialized();

    try {
      const filePath = this.getFilePath(key);
      if (fs.existsSync(filePath)) {
        await fs.promises.unlink(filePath);
      }
    } catch (error) {
      console.error(`Error deleting data for key ${key}:`, error);
    }
  }

  async has(key: string): Promise<boolean> {
    await this.ensureInitialized();

    const filePath = this.getFilePath(key);
    return fs.existsSync(filePath);
  }
}
