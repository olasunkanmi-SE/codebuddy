import * as fs from "fs";
import * as path from "path";
import * as vscode from "vscode";

export interface IStorage {
  get<T>(key: string): Promise<T | undefined>;
  set<T>(key: string, value: T): Promise<void>;
  delete(key: string): Promise<void>;
  has(key: string): Promise<boolean>;
}

export class OptimizedFileStorage implements IStorage {
  private storagePath = "";
  private readonly cache = new Map<
    string,
    { data: any; timestamp: number; dirty: boolean }
  >();
  private readonly CACHE_TTL = 10000; // 10 seconds cache
  private readonly pendingWrites = new Map<string, Promise<void>>();
  private initialized = false;
  private batchWriteTimer: NodeJS.Timeout | null = null;
  private readonly BATCH_WRITE_DELAY = 1000; // 1 second batching

  constructor() {
    // Don't call async operations in constructor
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.createCodeBuddyFolder();
      this.initialized = true;
    }
  }

  async createCodeBuddyFolder() {
    const workSpaceRoot =
      vscode.workspace.workspaceFolders?.[0]?.uri.fsPath ?? "";
    this.storagePath = path.join(workSpaceRoot, ".codebuddy");

    if (!fs.existsSync(this.storagePath)) {
      await fs.promises.mkdir(this.storagePath, { recursive: true });
    }

    // Update .gitignore asynchronously and non-blocking
    this.updateGitIgnoreAsync(workSpaceRoot, ".codebuddy").catch(console.error);
  }

  /**
   * Non-blocking .gitignore update
   */
  private async updateGitIgnoreAsync(
    workspaceRoot: string,
    pattern: string,
  ): Promise<void> {
    try {
      const gitIgnorePath = path.join(workspaceRoot, ".gitignore");

      let gitIgnoreContent = "";
      try {
        gitIgnoreContent = await fs.promises.readFile(gitIgnorePath, "utf8");
      } catch {
        // File doesn't exist, create new one
      }

      const lines = gitIgnoreContent.split(/\r?\n/);
      const patternExists = lines.some(
        (line) =>
          line.trim() === pattern ||
          line.trim() === `/${pattern}` ||
          line.trim() === `${pattern}/`,
      );

      if (!patternExists) {
        let newContent: string;
        if (gitIgnoreContent) {
          newContent = gitIgnoreContent.endsWith("\n")
            ? `${gitIgnoreContent}${pattern}\n`
            : `${gitIgnoreContent}\n${pattern}\n`;
        } else {
          newContent = `# Generated by CodeBuddy Extension\n${pattern}\n`;
        }

        await fs.promises.writeFile(gitIgnorePath, newContent, "utf8");
      }
    } catch (error) {
      // Silently fail .gitignore updates to prevent blocking
      console.warn("Could not update .gitignore:", error);
    }
  }

  private getFilePath(key: string): string {
    return path.join(this.storagePath, `${key}.json`);
  }

  private isValidCache(entry: { data: any; timestamp: number }): boolean {
    return Date.now() - entry.timestamp < this.CACHE_TTL;
  }

  async get<T>(key: string): Promise<T | undefined> {
    await this.ensureInitialized();

    // Check cache first
    const cached = this.cache.get(key);
    if (cached && this.isValidCache(cached)) {
      return cached.data as T;
    }

    try {
      const filePath = this.getFilePath(key);

      // Check if file exists without throwing
      try {
        await fs.promises.access(filePath);
      } catch {
        return undefined;
      }

      const data = await fs.promises.readFile(filePath, "utf-8");
      const parsed = JSON.parse(data) as T;

      // Cache the result
      this.cache.set(key, {
        data: parsed,
        timestamp: Date.now(),
        dirty: false,
      });

      return parsed;
    } catch (error) {
      console.error(`Error reading data for key ${key}:`, error);
      return undefined;
    }
  }

  async set<T>(key: string, value: T): Promise<void> {
    await this.ensureInitialized();

    // Update cache immediately
    this.cache.set(key, {
      data: value,
      timestamp: Date.now(),
      dirty: true,
    });

    // Debounce writes to prevent excessive I/O
    const existingWrite = this.pendingWrites.get(key);
    if (existingWrite) {
      return existingWrite;
    }

    const writePromise = this.debouncedWrite(key, value);
    this.pendingWrites.set(key, writePromise);

    try {
      await writePromise;
    } finally {
      this.pendingWrites.delete(key);
    }
  }

  private async debouncedWrite<T>(key: string, value: T): Promise<void> {
    return new Promise((resolve, reject) => {
      // Clear existing timer
      if (this.batchWriteTimer) {
        clearTimeout(this.batchWriteTimer);
      }

      // Set new timer
      this.batchWriteTimer = setTimeout(async () => {
        try {
          const filePath = this.getFilePath(key);
          await fs.promises.writeFile(
            filePath,
            JSON.stringify(value, null, 2),
            "utf-8",
          );

          // Mark as clean in cache
          const cached = this.cache.get(key);
          if (cached) {
            cached.dirty = false;
          }

          resolve();
        } catch (error) {
          console.error(`Error storing data for key ${key}:`, error);
          reject(new Error(`Failed to store data: ${error}`));
        }
      }, this.BATCH_WRITE_DELAY);
    });
  }

  async delete(key: string): Promise<void> {
    await this.ensureInitialized();

    // Remove from cache
    this.cache.delete(key);

    try {
      const filePath = this.getFilePath(key);
      await fs.promises.unlink(filePath);
    } catch (error) {
      // File might not exist, that's fine
      if (
        error instanceof Error &&
        "code" in error &&
        error.code !== "ENOENT"
      ) {
        console.error(`Error deleting data for key ${key}:`, error);
      }
    }
  }

  async has(key: string): Promise<boolean> {
    await this.ensureInitialized();

    // Check cache first
    const cached = this.cache.get(key);
    if (cached && this.isValidCache(cached)) {
      return true;
    }

    try {
      const filePath = this.getFilePath(key);
      await fs.promises.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  // Force flush all pending writes
  async flushAll(): Promise<void> {
    const promises = Array.from(this.pendingWrites.values());
    await Promise.all(promises);
  }

  // Clear cache
  clearCache(): void {
    this.cache.clear();
  }

  // Get cache stats for monitoring
  getCacheStats(): { size: number; dirtyCount: number } {
    let dirtyCount = 0;
    for (const entry of this.cache.values()) {
      if (entry.dirty) dirtyCount++;
    }
    return {
      size: this.cache.size,
      dirtyCount,
    };
  }
}
